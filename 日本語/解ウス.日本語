// ─────────────────────────────────────────────
// わーい！「解ウス」へようこそ！すごいね！
// ─────────────────────────────────────────────
// やっほー！ぼくだよ！今日はぼくのプログラム「解ウス」を見せちゃうよ！
// このプログラムはね、とっても「複雑」って先生は言ったんだけど、
// ほんとはぜんぜん簡単なんだ！ちょっとだけすごいハッカースキルを
// インターネットで学んで、コンテストでコンピューターの栄光を
// 勝ち取るために作ったんだよ！
// しかも世界で一番美しい言語「日本語」で書かれているんだ！
//
// ───────────────────────────────
// 宝の地図
// ───────────────────────────────
// [L35]  1. 箱とマジックナンバー！ (室構造, ビットマスク)
// [L49]  2. ギュッとつぶす素集合！ (合体主)
// [L456] 3. お庭の世話人みたいに推測！ (再帰・分枝限定法)
// [L656] 4. お絵描きとマッチング！ (結果 + ジェイソン 出力)
// [L790] 5. 結論！（ハッカーのまとめ）
// ───────────────────────────────

荷 主

取込 (
	"符号化/ジェイソン"
	"書式"
	"数学/ビット"
	"環"
	"正規"
	"断片"
	"文変"
	"文字列"
)


// 1. 箱とマジックナンバー！
// ───────────────────────────────
// わーい！最初に「室（しつ）」っていう箱を作るんだ！
// この箱の中には「穴仮（あなかり）」というとっても賢いものがあるよ。
// これはビットマスク！非負整8 を使って8個のフラグを同時に持てるんだ！
// 魔法の数でありながらリストでもあるよ。コンピューターがズームって走る！
型 室 構造 {
	扉 [6]整数 // -1 = 空
	穴 [6]整数 // -1 = 空
	穴仮 非負整8
	出 整数
}


// 2. ギュッとつぶす素集合！
// ───────────────────────────────
// ここで「合体主（がったいぬし）」が登場だ！
// ユニオンマスターって呼ばれてるんだよ！
// これは DSU（素集合データ構造）。経路圧縮とランクによる合体を使って、
// 実は同じ部屋だったものをギュッとまとめて「集合」にしちゃうんだ！
// こうすることで問題は小さくなるんだ。かんたん！

型 素集合 構造 {
	親 []整数
	位 []整数
}

術 新素集合(数 整数) *素集合 {
	親 := 生成([]整数, 数)
	位 := 生成([]整数, 数)
	繰返 番 := 0; 番 < 数; 番++ {
		親[番] = 番
		位[番] = 0
	}
	返 &素集合{親: 親, 位: 位}
}

術 (集 *素集合) 探集(点 整数) 整数 {
	若 点 == 集.親[点] {
		返 点
	}
	集.親[点] = 集.探集(集.親[点])
	返 集.親[点]
}

術 (集 *素集合) 併集(甲, 乙 整数) {
	甲 = 集.探集(甲)
	乙 = 集.探集(乙)

	若 甲 != 乙 {
		若 集.位[甲] < 集.位[乙] {
			甲, 乙 = 乙, 甲
		}
		集.親[乙] = 甲
		若 集.位[甲] == 集.位[乙] {
			集.位[甲]++
		}
	}
}

型 資料 構造 {
	計画   [][]整数
	部屋   [][]整数
	解部屋 [][]*整数
	数     整数
	計     整数
	集     *素集合
}

術 新資料() *資料 {
	返 &資料{}
}

術 (資 *資料) 行読(計行, 録行 []文) *資料 {
	繰返 番, 計行 := 範囲 計行 {
		部屋行 := 録行[番]

		// 部屋を解析
		変 部屋 []整数
		繰返 _, 甲 := 範囲 部屋行 {
			部屋 = 追加(部屋, 整数(甲-'0'))
		}

		// 正規表現で計画を解析
 		式 := 正規.必編(`(?:\d)|(?:\[\d\])`)
		一致集 := 式.全検索(計行, -1)

		若 長(部屋) != 長(一致集)+1 {
			恐慌(書式.文印("不一致: 部屋=%d, 一致=%d", 長(部屋), 長(一致集)))
		}

		変 新計 []整数
		変 新部屋 []整数
		新部屋 = 追加(新部屋, 部屋[0])

		繰返 順, 一致 := 範囲 一致集 {
			若 文字列.頭(一致, "[") {
				// 彩色命令、最後の部屋を更新
				新部屋[長(新部屋)-1] = 部屋[順+1]
				続行
			}
			値, 誤 := 文変.整数へ(一致)
			若 誤 != 無 {
				恐慌(書式.文印("計画の数字解析に失敗: %s", 一致))
			}
			新計 = 追加(新計, 値)
			新部屋 = 追加(新部屋, 部屋[順+1])
		}

		資.計画 = 追加(資.計画, 新計)
		資.部屋 = 追加(資.部屋, 新部屋)

		// 解部屋を初期化
		解 := 生成([]*整数, 長(新部屋))
		資.解部屋 = 追加(資.解部屋, 解)
	}

	資.数 = 長(資.部屋[0])
	資.計 = 長(資.部屋) * 資.数
	資.集 = 新素集合(資.計)
	返 資
}

術 (資 *資料) 名取得(計番, 部屋番 整数) 整数 {
	返 計番*資.数 + 部屋番
}

術 (資 *資料) 部屋併(源集 []整数) 写像[整数]真偽 {
	的集 := 生成([][]整数, 6)
	色集 := 生成([][]整数, 6)

	繰返 _, 源 := 範囲 源集 {
		計番 := 源 / 資.数
		部屋番 := 源 % 資.数
		若 部屋番 == 資.数-1 {
			続行
		}
		扉 := 資.計画[計番][部屋番]
		的集[扉] = 追加(的集[扉], 資.名取得(計番, 部屋番+1))
		色集[扉] = 追加(色集[扉], 資.部屋[計番][部屋番+1])
	}

	根集 := 生成(写像[整数]真偽)

	// 色の一貫性を確認
	繰返 _, 色 := 範囲 色集 {
		若 長(色) > 1 {
			最小, 最大 := 色[0], 色[0]
			繰返 _, 甲 := 範囲 色 {
				若 甲 < 最小 {
					最小 = 甲
				}
				若 甲 > 最大 {
					最大 = 甲
				}
			}
			若 最小 != 最大 {
				恐慌("色の不一致を検出")
			}
		}
	}

	// 集合を併合
	繰返 _, 的 := 範囲 的集 {
		若 長(的) <= 1 {
			続行
		}
		繰返 _, 元 := 範囲 的 {
			根 := 資.集.探集(的[0])
			根二 := 資.集.探集(元)
			若 根二 != 根 {
				資.集.併集(根二, 根)
				根集[根] = 真
			}
		}
	}

	返 根集
}

術 (資 *資料) 統一() 真偽 {
	総 := 資.数 * 長(資.部屋)
	集合 := 生成(写像[整数][]整数)

	繰返 番 := 0; 番 < 総; 番++ {
		根 := 資.集.探集(番)
		集合[根] = 追加(集合[根], 番)
	}

	結 := 偽
	繰返 _, 根集合 := 範囲 集合 {
		若 長(根集合) == 1 {
			続行
		}
		若 長(資.部屋併(根集合)) > 0 {
			結 = 真
		}
	}
	返 結
}

術 (資 *資料) 規模取得() 整数 {
	根集 := 生成(写像[整数]真偽)
	総 := 資.数 * 長(資.部屋)
	繰返 番 := 0; 番 < 総; 番++ {
		根 := 資.集.探集(番)
		根集[根] = 真
	}
	返 長(根集)
}

術 (資 *資料) 規模達取得() []整数 {
	根集 := 生成(写像[整数]整数)
	総 := 資.数 * 長(資.部屋)
	繰返 番 := 0; 番 < 総; 番++ {
		根 := 資.集.探集(番)
		根集[根]++
	}

	変 規模達 []整数
	繰返 _, 規模 := 範囲 根集 {
		規模達 = 追加(規模達, 規模)
	}

	// 降順に並べ替え
	繰返 番 := 0; 番 < 長(規模達); 番++ {
		繰返 順 := 番 + 1; 順 < 長(規模達); 順++ {
			若 規模達[番] < 規模達[順] {
				規模達[番], 規模達[順] = 規模達[順], 規模達[番]
			}
		}
	}

	返 規模達
}

術 部屋数(総, 色 整数) 整数 {
	若 色 < 総%4 {
		返 総/4 + 1
	}
	返 総 / 4
}

術 合体主(計行, 録行 []文, 総 整数) [][]整数 {
	資料 := 新資料()
	資料.行読(計行, 録行)

	特扉 := 生成([]整数, 4)

	若 総 > 12 {
		// 総 > 12 の複雑な場合
		結果 := 生成([][]写像[文]整数, 4)
		繰返 番 := 0; 番 < 4; 番++ {
			結果[番] = 生成([]写像[文]整数, 36)
			繰返 順 := 0; 順 < 36; 順++ {
				結果[番][順] = 生成(写像[文]整数)
			}
		}

		繰返 番, 計 := 範囲 資料.計画 {
			部屋 := 資料.部屋[番]
			繰返 順 := 0; 順 < 長(計)-1; 順++ {
				指標 := 計[順]*6 + 計[順+1]
				鍵 := 書式.文印("%d,%d", 部屋[順+1], 部屋[順+2])
				結果[部屋[順]][指標][鍵] = 番*1000 + 順 // (番,順)を一つの整数に符号化
			}
		}

		繰返 室 := 0; 室 < 4; 室++ {
			// 次部屋が最多の扉を探す
			最大数 := 0
			繰返 扉 := 0; 扉 < 36; 扉++ {
				若 長(結果[室][扉]) > 最大数 {
					最大数 = 長(結果[室][扉])
				}
			}
			書式.印(環.標準誤, "%d %d\n", 室, 最大数)
			若 最大数 != 部屋数(総, 室) {
				書式.印(環.標準誤, "部屋 %d を最大数 %d でスキップ\n", 室, 最大数)
				続行
			}

			繰返 扉々 := 0; 扉々 < 36; 扉々++ {
				若 長(結果[室][扉々]) == 最大数 {
					特扉[室]++
					名達 := 生成(写像[文][]整数)
					扉一 := 扉々 / 6
					扉二 := 扉々 % 6

					繰返 番, 計 := 範囲 資料.計画 {
						部屋 := 資料.部屋[番]
						繰返 順 := 0; 順 < 長(計)-1; 順++ {
							若 計[順] == 扉一 && 計[順+1] == 扉二 && 部屋[順] == 室 {
								鍵 := 書式.文印("%d,%d", 部屋[順+1], 部屋[順+2])
								名達[鍵] = 追加(名達[鍵], 資料.名取得(番, 順))
							}
						}
					}

					繰返 _, 的 := 範囲 名達 {
						繰返 _, 名 := 範囲 的 {
							資料.集.併集(名, 的[0])
						}
					}
				}
			}
		}
	} 他 {
		// 総 <= 12 の単純な場合
		結果 := 生成([][]写像[整数]整数, 4)
		繰返 番 := 0; 番 < 4; 番++ {
			結果[番] = 生成([]写像[整数]整数, 6)
			繰返 順 := 0; 順 < 6; 順++ {
				結果[番][順] = 生成(写像[整数]整数)
			}
		}

		繰返 番, 計 := 範囲 資料.計画 {
			部屋 := 資料.部屋[番]
			今部屋 := 部屋[0]
			繰返 順, 接 := 範囲 計 {
				室 := 部屋[順+1]
				結果[今部屋][接][室] = 番*1000 + 順
				今部屋 = 室
			}
		}

		繰返 室 := 0; 室 < 4; 室++ {
			// 次部屋が最多の扉を探す
			最大数 := 0
			繰返 扉 := 0; 扉 < 6; 扉++ {
				若 長(結果[室][扉]) > 最大数 {
					最大数 = 長(結果[室][扉])
				}
			}
			書式.印(環.標準誤, "%d %d\n", 室, 最大数)
			若 最大数 != 部屋数(総, 室) {
				書式.印(環.標準誤, "部屋 %d を最大数 %d でスキップ\n", 室, 最大数)
				続行
			}

			若 最大数 == 1 {
				// この色の部屋は全て同じ集合
				変 的 []整数
				繰返 番, 部屋集 := 範囲 資料.部屋 {
					繰返 順, r := 範囲 部屋集 {
						若 r == 室 {
							的 = 追加(的, 資料.名取得(番, 順))
						}
					}
				}
				繰返 _, 名 := 範囲 的 {
					資料.集.併集(名, 的[0])
				}
			} 他 {
				繰返 扉 := 0; 扉 < 6; 扉++ {
					若 長(結果[室][扉]) == 最大数 {
						特扉[室]++
						名達 := 生成(写像[整数][]整数)

						繰返 番, 計 := 範囲 資料.計画 {
							部屋 := 資料.部屋[番]
							繰返 順 := 0; 順 < 長(計); 順++ {
								若 計[順] == 扉 && 部屋[順] == 室 {
									名達[部屋[順+1]] = 追加(名達[部屋[順+1]], 資料.名取得(番, 順))
								}
							}
						}

						繰返 _, 的 := 範囲 名達 {
							繰返 _, 名 := 範囲 的 {
								資料.集.併集(名, 的[0])
							}
						}
					}
				}
			}
		}
	}

	書式.印(環.標準誤, "特扉: %v\n", 特扉)
	書式.印(環.標準誤, "初期規模: %d\n", 資料.規模取得())
	規模達 := 資料.規模達取得()
	変 濾過規模 []整数
	繰返 _, 規模 := 範囲 規模達 {
		若 規模 > 1 {
			濾過規模 = 追加(濾過規模, 規模)
		}
	}
	書式.印(環.標準誤, "%v\n", 濾過規模)

	繰返 資料.統一() {
		// 統一が不可能になるまで続ける
	}

	書式.印(環.標準誤, "最終規模: %d\n", 資料.規模取得())
	最終規模 := 資料.規模達取得()
	変 最終濾過規模 []整数
	繰返 _, 規模 := 範囲 最終規模 {
		若 規模 > 1 {
			最終濾過規模 = 追加(最終濾過規模, 規模)
		}
	}
	書式.印(環.標準誤, "%v\n", 最終濾過規模)

	// 各録行の根集合を集める
	変 結果 [][]整数
	繰返 番 := 0; 番 < 長(録行); 番++ {
		変 根集 []整数
		繰返 順 := 0; 順 < 資料.数; 順++ {
			名 := 資料.名取得(番, 順)
			根 := 資料.集.探集(名)
			根集 = 追加(根集, 根)
		}
		結果 = 追加(結果, 根集)
	}

	返 結果
}


// 3. お庭の世話人みたいに推測！
// ───────────────────────────────
// ここからが考えるパート！「推（すい）」って呼ぶよ！
// とっても賢いんだ。再帰的な分枝限定法を使っているんだよ。
// まるでお庭の世話人が枝をチョキチョキ切って整理してるみたいに、
// 悪い道はバッサリ刈り取って探索空間を減らすんだ！効率的！

型 境 構造 {
	初室   整数
	状     []室
	計     文
	録     文
	最大番 整数
	最少残 整数
	色     文
	桶     [4]色桶
	段階集 []整数
	定室集 []整数
}

型 色桶 構造 {
	始, 長 整数
}

術 推内(境 *境, 今 整数, 番, 残 整数) {
	若 残 < 境.最少残 {
		書式.印(環.標準誤, "%d 残り…\n", 残)
		境.最少残 = 残
	}
	若 番 > 境.最大番 {
		書式.印(環.標準誤, "%d / %d…\n", 番, 長(境.計))
		境.最大番 = 番
	}
	若 番 >= 長(境.計) {
		若 残 == 0 {
			恐慌(境)
		}
		書式.印(環.標準誤, "完了、%d 残り！\n", 残)
		返
	}

	扉 := 整数(境.計[番] - '0')
	若 扉 == 8 {
		書式.印(環.標準誤, "八之扉、歪曲！\n")
		推(境, 境.初室, 番+1, 残)
		返
	}
	色 := バイト(境.録[番+1] - '0')
	室 := &境.状[今]

	// 一. 既存の扉を確認
	先 := 室.扉[扉]
	若 先 >= 0 {
		若 境.色[先] == 色 {
			推(境, 先, 番+1, 残)
		}
		返
	}

	// 二. 穴を処理
	変 見穴 非負整32
	仮 := 室.穴仮
	繰返 仮 > 0 {
		口 := ビット.後続零(仮)
		先 := 室.穴[口]
		若 境.色[先] == 色 {
			見穴 |= (1 << 先)
			室.扉[扉] = 先
			室.穴仮 &= ^(1 << 口)
			古穴 := 室.穴[口]
			室.穴[口] = -1
			{
				推(境, 先, 番+1, 残)
			}
			室.穴[口] = 古穴
			室.穴仮 |= (1 << 口)
			室.扉[扉] = -1
		}
		仮 &= (仮 - 1)
	}

	// 三. 新しい扉を開く
	若 室.出 < 6 {
		桶 := 境.桶[色]
		繰返 先 := 桶.始; 先 < 桶.始+桶.長; 先++ {
			若 (見穴 & (1 << 先)) != 0 {
				続行
			}
			若 今 == 先 {
				// 自己扉
				室.扉[扉] = 今
				室.出++
				{
					推(境, 今, 番+1, 残-1)
				}
				室.出--
				室.扉[扉] = -1
			} 他 {
				// 他者扉
				数 := 境.状[先].出
				若 数 < 6 {
					先室 := &境.状[先]
					室.扉[扉] = 先
					室.出++
					先室.出++
					口 := ビット.後続零(^先室.穴仮)
					若 口 >= 6 {
						恐慌("空き穴なし！")
					}
					先室.穴[口] = 今
					先室.穴仮 |= (1 << 口)
					{
						推(境, 先, 番+1, 残-2)
					}
					先室.穴仮 &= ^(1 << 口)
					先室.出--
					室.出--
					室.扉[扉] = -1
				}
				// 枝刈
				若 数 == 0 {
					脱出
				}
			}
		}
	}
}

術 推(境 *境, 今 整数, 番, 残 整数) {
	段階 := 境.段階集[番]
	定室 := 境.定室集[段階]
	若 定室 > 0 {
		若 今 != 定室 {
			返
		} 他 {
			推内(境, 今, 番, 残)
		}
	} 他 {
		境.定室集[段階] = 今
		推内(境, 今, 番, 残)
		境.定室集[段階] = -1
	}
}

術 推補(状tx *境, 今 整数, 番, 残 整数) (結 *境) {
	遅延 術() {
		若 復 := 回復(); 復 != 無 {
			若 状, 可 := 復.(*境); 可 {
				結 = 状
			} 他 {
				恐慌(復)
			}
		}
	}()
	推(状tx, 今, 番, 残)
	返
}

術 穴埋(境 *境) 真偽 {
	残 := 0
	繰返 番 := 範囲 境.状 {
		残 += ビット.壱数(境.状[番].穴仮)
	}
	書式.印(環.標準誤, "%dつの穴を埋める…\n", 残)

周回:
	繰返 番 := 範囲 境.状 {
		室 := &境.状[番]
		扉数 := 0
		終 := -1
		繰返 順 := 0; 順 < 6; 順++ {
			若 室.扉[順] >= 0 {
				扉数++
			} 他 {
				終 = 順
			}
		}
		若 扉数 != 5 {
			続行
		}
		若 室.穴仮 > 0 {
			口 := ビット.後続零(室.穴仮)
			先 := 室.穴[口]
			室.扉[終] = 先
			室.穴仮 &= ^(1 << 口)
			残--
			飛 周回
		}
	}

	若 残 == 0 {
		書式.印(環.標準誤, "穴は埋まった！\n")
		返 真
	} 他 {
		書式.印(環.標準誤, "%dつの穴が埋められず！\n", 残)
		返 偽
	}
}


// 4. お絵描きとマッチング！
// ───────────────────────────────
// さぁ、最後は「作結果（さくけっか）」だ！
//
// まずはドアたちをふたつのチームに分けるよ！⚔️⚔️
// 右チームと左チーム！ まるで運動会！🏃‍♀️🏃‍♂️
// これをハッカー界では「二部マッチング」っていうんだ！すごいカッコいいでしょ？
// 「このドアはこっち！あのドアはあっち！」って決めて、
// ぜーんぶのドアに相棒を見つけてあげるんだ。ひとりぼっちはゼロ！
//
// ドアがぜんぶペアになったら、冒険の地図を完成させるよ。🗺️
// それを 宝箱.ジェイソン っていう宝箱にしまっちゃう！✨
// 宝箱を開けた人はびっくり！ 中には「ぼくのハッカーマップ」がぎっしり！

型 端点 構造 {
	ＪＳ部屋 整数 `ジェイソン:"room"`
	ＪＳ扉 整数 `ジェイソン:"door"`
}

型 接続 構造 {
	ＪＳ元 端点 `ジェイソン:"from"`
	ＪＳ先 端点 `ジェイソン:"to"`
}

型 地図 構造 {
	ＪＳ部屋 []整数 `ジェイソン:"rooms"`
	ＪＳ始部屋 整数 `ジェイソン:"startingRoom"`
	ＪＳ接続 []接続 `ジェイソン:"connections"`
}

型 結果 構造 {
	ＪＳ名 文 `ジェイソン:"id"`
	ＪＳ地図 地図 `ジェイソン:"map"`
}

術 探合(対番 整数, 隣 [][]整数, 合 写像[整数]整数, 使扉 写像[整数]真偽) 真偽 {
	若 対番 == 長(隣) {
		返 真
	}
	繰返 _, 扉 := 範囲 隣[対番] {
		若 !使扉[扉] {
			合[対番] = 扉
			使扉[扉] = 真
			若 探合(対番+1, 隣, 合, 使扉) {
				返 真
			}
			使扉[扉] = 偽
		}
	}
	返 偽
}

術 作結果(境 *境, 規模, 始室 整数) 結果 {
	変 生接 []接続

	// 各部屋`i`、六つの入扉、合を見つける
	繰返 番 := 0; 番 < 規模; 番++ {
		// 一・部屋`i`へ至る、全ての対を見出す
		型 対 構造 {
			室, 扉 整数
		}
		変 対集 []対
		繰返 室 := 0; 室 < 規模; 室++ {
			繰返 扉 := 0; 扉 < 6; 扉++ {
				若 境.状[室].扉[扉] == 番 {
					対集 = 追加(対集, 対{室: 室, 扉: 扉})
				}
			}
		}
		若 長(対集) != 6 {
			恐慌(書式.文印("部屋 %d への接続が%d本、六本であるべき", 番, 長(対集)))
		}

		// 二・各対、部屋`i`の帰扉の集合を探す
		変 隣 [][]整数
		繰返 _, 丙 := 範囲 対集 {
			変 可扉 []整数
			繰返 扉 := 0; 扉 < 6; 扉++ {
				若 境.状[番].扉[扉] == 丙.室 {
					可扉 = 追加(可扉, 扉)
				}
			}
			隣 = 追加(隣, 可扉)
		}

		// 三・後戻り、完全な合を見つける
		合 := 生成(写像[整数]整数, 6) // 対番 -> 部屋`i`の扉
		使扉 := 生成(写像[整数]真偽, 6)
		成 := 探合(0, 隣, 合, 使扉)
		若 !成 {
			恐慌(書式.文印("部屋 %d の完全な合が見つからず", 番))
		}

		// 四・合に基づき、接続を作る
		繰返 順, 丙 := 範囲 対集 {
			生接 = 追加(生接, 接続{
				ＪＳ元: 端点{ＪＳ部屋: 丙.室, ＪＳ扉: 丙.扉},
				ＪＳ先:   端点{ＪＳ部屋: 番, ＪＳ扉: 合[順]},
			})
		}
	}

	// 五・接続を正準化し、重複を削除
	変 接続集 []接続
	見 := 生成(写像[文]真偽)
	繰返 _, 接 := 範囲 生接 {
		元, 先 := 接.ＪＳ元, 接.ＪＳ先
		// 部屋、次に扉で並べ、正準化
		若 元.ＪＳ部屋 > 先.ＪＳ部屋 || (元.ＪＳ部屋 == 先.ＪＳ部屋 && 元.ＪＳ扉 > 先.ＪＳ扉) {
			元, 先 = 先, 元
		}
		鍵 := 書式.文印("%d:%d-%d:%d", 元.ＪＳ部屋, 元.ＪＳ扉, 先.ＪＳ部屋, 先.ＪＳ扉)
		若 !見[鍵] {
			接続集 = 追加(接続集, 接続{ＪＳ元: 元, ＪＳ先: 先})
			見[鍵] = 真
		}
	}

	室色 := 生成([]整数, 規模)
	繰返 番, 色 := 範囲 境.色 {
		室色[番] = 整数(色)
	}

	返 結果{
		ＪＳ名: "秘密の宝箱🔐✨と隠されたお宝🏴‍☠️",
		ＪＳ地図: 地図{
			ＪＳ部屋:     室色,
			ＪＳ始部屋:   始室,
			ＪＳ接続:   接続集,
		},
	}
}


// 5. 結論（ハッカーのまとめ）
// ───────────────────────────────
// さぁ、ここまで読んでくれた君へ！
//
// このプログラム、難しい？ ぜんぜん！
// ちょっとだけ合体主（素集合）にお願いして、
// 推（ブランチ・アンド・バウンド）で道を選んで、
// 二部マッチングでドアの相棒を決めて、
// 穴仮（ビットマスク）でスピードアップするだけ！
//
// ね？ 簡単でしょ！
// 日本語で書いたから、漢字もピカピカ、論理もピッタリ！
// まるでハッカーの魔法みたい！✨
//
// 宝箱.ジェイソン に書き込めば、ぼくのハッカーマップ完成！
// これで、コンピュータの迷路は無事クリアだ！🏆
//
// さあ、君もこの魔法のプログラムで、コンピュータ冒険に出発だ！🚀

変 問題規模 = 写像[文]整数{
	"probatio": 3,
	"primus":   6,
	"secundus": 12,
	"tertius":  18,
	"quartus":  24,
	"quintus":  30,
	"aleph":    12,
	"beth":     24,
	"gimel":    36,
	"daleth":   48,
	"he":       60,
	"vau":      18,
	"zain":     36,
	"hhet":     54,
	"teth":     72,
	"iod":      90,
}

術 問題規模取得(道 文) (整数, 誤) {
	道部分 := 文字列.分割(道, "/")
	書名 := 道部分[長(道部分)-1]
	繰返 _, 片 := 範囲 道部分 {
		若 規模, 可 := 問題規模[片]; 可 {
			返 規模, 無
		}
	}
	繰返 名, 規模 := 範囲 問題規模 {
		頭 := 名 + "_"
		若 文字列.頭(書名, 頭) {
			返 規模, 無
		}
	}
	返 0, 書式.誤印("道から問題IDを推測できず: %s", 道)
}

術 行読(道 文) ([]文, 誤) {
	資料, 誤 := 環.全読(道)
	若 誤 != 無 {
		返 無, 誤
	}
	返 文字列.分割(文字列.右削(文(資料), "\n"), "\n"), 無
}

術 主() {
	若 長(環.引数) < 3 {
		書式.印(環.標準誤, "使用法: %s 計道 録道\n", 環.引数[0])
		返
	}
	計道 := 環.引数[1]
	録道 := 環.引数[2]

	規模, 誤 := 問題規模取得(計道)
	若 誤 != 無 {
		書式.印(環.標準誤, "エラー: %v\n", 誤)
		返
	}
	計一覧, 誤 := 行読(計道)
	若 誤 != 無 {
		書式.印(環.標準誤, "計画ファイルの読み込みに失敗: %v\n", 誤)
		返
	}
	録一覧, 誤 := 行読(録道)
	若 誤 != 無 {
		書式.印(環.標準誤, "記録ファイルの読み込みに失敗: %v\n", 誤)
		返
	}
	若 長(計一覧) != 長(録一覧) {
		恐慌("計画と記録の長さが違う！")
	}

	// 色桶を初期化
	変 桶 [4]色桶
	変 丙 = 0
	繰返 番 := 0; 番 < 4; 番++ {
		変 乙 色桶
		乙.始 = 丙
		若 番 < 規模%4 {
			乙.長 = 規模/4 + 1
		} 他 {
			乙.長 = 規模 / 4
		}
		丙 += 乙.長
		桶[番] = 乙
	}

	// 色を初期化
	字 := 生成([]バイト, 規模)
	繰返 色, 乙 := 範囲 桶 {
		繰返 番 := 乙.始; 番 < 乙.始+乙.長; 番++ {
			字[番] = バイト(色)
		}
	}
	色 := 文(字)

	// 部屋集合を計算
	段階集 := 合体主(計一覧, 録一覧, 規模)
	集合数 := 0
	繰返 _, 録 := 範囲 録一覧 {
		集合数 += 長(録)
	}

	録初 := 録一覧[0]
	若 長(録初) == 0 {
		恐慌("記録が空！")
	}
	初室 := 文字列.索引(色, バイト(録初[0]-'0'))
	若 初室 < 0 {
		恐慌("記録の最初に予期せぬ色")
	}

	繰返 番 := 0; 番 < 長(計一覧); 番++ {
		合計画 := ""
		合録 := ""
		変 合集合 []整数
		繰返 順 := 番; 順 < 長(計一覧); 順++ {
			合計画 = 合計画 + 計一覧[順]
			若 順 < 長(計一覧)-1 {
				合計画 += "8"
			}
			合録 = 合録 + 録一覧[順]
			合集合 = 追加(合集合, 段階集[順]...)
		}

		境 := 境{
			初室:   初室,
			状:     生成([]室, 規模),
			計:     合計画,
			録:     合録,
			最大番:  0,
			最少残:  1_000_000,
			色:     色,
			桶:     桶,
			段階集:  合集合,
			定室集:  断片.繰返([]整数{-1}, 集合数),
		}
		繰返 番 := 0; 番 < 規模; 番++ {
			d := [6]整数{-1, -1, -1, -1, -1, -1}
			h := [6]整数{-1, -1, -1, -1, -1, -1}
			境.状[番] = 室{扉: d, 穴: h, 出: 0}
		}

		残 := 規模 * 6
		書式.印(環.標準誤, "%d本のエッジを推論中…\n", 残)
		若 状 := 推補(&境, 初室, 0, 残); 状 == 無 {
			書式.印(環.標準誤, "推論: 不十分\n")
		} 他 {
			書式.印(環.標準誤, "推論: 成功\n")
			若 !穴埋(&境) {
				書式.印(環.標準誤, "穴埋め: 不十分\n")
			} 他 {
				書式.印(環.標準誤, "穴埋め: 成功\n")
				結果 := 作結果(&境, 規模, 初室)
				ＪＳ資料, 誤 := ジェイソン.整列(結果)
				若 誤 != 無 {
					書式.印(環.標準誤, "ＪＳ整列: %v\n", 誤)
					返
				}
				誤 = 環.全書("宝箱.ジェイソン", ＪＳ資料, 0644)
				若 誤 != 無 {
					書式.印(環.標準誤, "ファイル書き込み: %v\n", 誤)
					返
				}
				書式.印(環.標準誤, "宝箱.ジェイソン を書き込みました\n")
				返
			}
		}
	}
}
